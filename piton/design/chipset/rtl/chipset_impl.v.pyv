// Copyright (c) 2015 Princeton University
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Princeton University nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

`include "define.tmp.h"
`include "piton_system.vh"
`include "mc_define.h"
`ifdef PITONSYS_AXI4_MEM
`include "axi_defines.vh"
`endif
`include "uart16550_define.vh"
`include "chipset_define.vh"

// Filename: chipset_impl.v
// Author: mmckeown
// Description: Top-level chipset implementation.  Instantiates
//              different versions of chipsets based on different
//              macros.  Some logic is common to all chipset implementations.

// Macros used in this file:
//  PITON_FPGA_MC_DDR                  Set to indicate an FPGA implementation will
//                                      use a DDR2/3 memory controller.  If
//                                      this is not set, a default "fake"
//                                      simulated DRAM is used.
//  PITONSYS_NO_MC                      If set, no memory controller is used. This is used
//                                      in the testing of the Piton system, where a small test
//                                      can be run on the chip with DRAM
//                                      emulated in BRAMs
//  PITONSYS_IOCTRL                     Set to use real I/O controller, otherwise a fake I/O bridge
//                                      is used and emulates I/O in PLI C calls.  This may not be compatible
//                                      with the "fake" memory controller or no memory controller at all
//  PITONSYS_UART                       Set to include a UART in the Piton system chipset.  The UART
//                                      can be used as an I/O device and/or a device for bootloading
//                                      test programs (see PITONSYS_UART_BOOT)
//  PITONSYS_UART_LOOBACK               Set to looback UART to itself.  Used for testing purposes
//  PITONSYS_UART_BOOT                  Set for UART boot hardware to be included.  If this is the
//                                      only boot option set, it is always used.  If there is another
//                                      boot option, a switch can be used to enable UART boot
//  PITONSYS_SPI                        Set to include a SPI in the Piton system chipset.  SPI is generally
//                                      used for SD card boot, but could potentially be used for other
//                                      purposes
//  NEXYS4DDR_BOARD NEXYSVIDEO_BOARD    Used to indicate which board this code is
//                                      being synthesized for. There are more than just these
<%
import os
import sys
import pyhplib
from pyhplib import *
devices = pyhplib.ReadDevicesXMLFile()

sys.path.append(os.environ["DV_ROOT"]+"/design/chipset/io_xbar/parameter")
import io_xbar_node_define

DYNAMIC_NODE_PORT = io_xbar_node_define.DYNAMIC_NODE_PORT
%>

module chipset_impl(
    // Clocks and resets
    input                                       chipset_clk,
    input                                       chipset_rst_n,
    input                                       piton_ready_n,
`ifdef PITON_MULTICHIP
    input [`CHIP_ID_WIDTH-1:0]                  chipid, 
`endif

    output                                      test_start,
    output                                      uart_rst_out_n,
`ifdef PITONSYS_PCIE_CFG
    output                                      pcie_cfg_rst_out_n,
    output [`PITONSYS_SW_WIDTH-1:0]             pcie_cfg_sw_out,
`endif

    // invalid access inside packet filter
    output                                      invalid_access_o,

`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR
`ifndef F1_BOARD
`ifdef PITONSYS_DDR4
    input                                       mc_clk_p,
    input                                       mc_clk_n,
`else  // PITONSYS_DDR4
    input                                       mc_clk,
`endif // PITONSYS_DDR4
`endif // ifndef F1_BOARD
`endif // endif PITON_FPGA_MC_DDR
`endif // endif PITONSYS_NO_MC

    // Main chip interface
    output [`NOC_DATA_WIDTH-1:0]                chipset_intf_data_noc1,
    output [`NOC_DATA_WIDTH-1:0]                chipset_intf_data_noc2,
    output [`NOC_DATA_WIDTH-1:0]                chipset_intf_data_noc3,
    output                                      chipset_intf_val_noc1,
    output                                      chipset_intf_val_noc2,
    output                                      chipset_intf_val_noc3,
    input                                       chipset_intf_rdy_noc1,
    input                                       chipset_intf_rdy_noc2,
    input                                       chipset_intf_rdy_noc3,

    input  [`NOC_DATA_WIDTH-1:0]                intf_chipset_data_noc1,
    input  [`NOC_DATA_WIDTH-1:0]                intf_chipset_data_noc2,
    input  [`NOC_DATA_WIDTH-1:0]                intf_chipset_data_noc3,
    input                                       intf_chipset_val_noc1,
    input                                       intf_chipset_val_noc2,
    input                                       intf_chipset_val_noc3,
    output                                      intf_chipset_rdy_noc1,
    output                                      intf_chipset_rdy_noc2,
    output                                      intf_chipset_rdy_noc3

`ifdef PITONSYS_PCIE
    ,
    input pcie_clk_n,
    input pcie_clk_p, 
    input pcie_rst_n,
    output [15:0] pcie_txp,
    output [15:0] pcie_txn,
    input [15:0] pcie_rxp,
    input [15:0] pcie_rxn
`endif // PITONSYS_PCIE

    // DRAM and I/O interfaces
`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR
    ,
    output                                      init_calib_complete
`ifndef F1_BOARD
    // Generalized interface for any FPGA board we support.
    // Not all signals will be used for all FPGA boards (see constraints)
`ifdef PITONSYS_DDR4
    ,
    output                                      ddr_act_n,
    output [`DDR_BG_WIDTH-1:0]                 ddr_bg,
`else // PITONSYS_DDR4
    ,
    output                                      ddr_cas_n,
    output                                      ddr_ras_n,
    output                                      ddr_we_n,
`endif // PITONSYS_DDR4
    output [`DDR_ADDR_WIDTH-1:0]               ddr_addr,
    output [`DDR_BA_WIDTH-1:0]                 ddr_ba,
    output [`DDR_CK_WIDTH-1:0]                 ddr_ck_n,
    output [`DDR_CK_WIDTH-1:0]                 ddr_ck_p,
    output [`DDR_CKE_WIDTH-1:0]                ddr_cke,
    output                                      ddr_reset_n,
    inout  [`DDR_DQ_WIDTH-1:0]                 ddr_dq,
    inout  [`DDR_DQS_WIDTH-1:0]                ddr_dqs_n,
    inout  [`DDR_DQS_WIDTH-1:0]                ddr_dqs_p,
`ifndef NEXYSVIDEO_BOARD
    output [`DDR_CS_WIDTH-1:0]                 ddr_cs_n,
`endif // endif NEXYSVIDEO_BOARD
`ifdef PITONSYS_DDR4
`ifdef XUPP3R_BOARD
    output                                      ddr_parity,
`else
    inout [`DDR_DM_WIDTH-1:0]                  ddr_dm,
`endif // XUPP3R_BOARD
`else // PITONSYS_DDR4
    output [`DDR_DM_WIDTH-1:0]                 ddr_dm,
`endif // PITONSYS_DDR4
    output [`DDR_ODT_WIDTH-1:0]                ddr_odt
`else // ifndef F1_BOARD
    ,
    input                                    ddr_axi_clk,
    input                                    ddr_axi_resetn,
    output wire [`AXI4_ID_WIDTH     -1:0]    ddr_axi_awid,
    output wire [`AXI4_ADDR_WIDTH   -1:0]    ddr_axi_awaddr,
    output wire [`AXI4_LEN_WIDTH    -1:0]    ddr_axi_awlen,
    output wire [`AXI4_SIZE_WIDTH   -1:0]    ddr_axi_awsize,
    output wire [`AXI4_BURST_WIDTH  -1:0]    ddr_axi_awburst,
    output wire                              ddr_axi_awlock,
    output wire [`AXI4_CACHE_WIDTH  -1:0]    ddr_axi_awcache,
    output wire [`AXI4_PROT_WIDTH   -1:0]    ddr_axi_awprot,
    output wire [`AXI4_QOS_WIDTH    -1:0]    ddr_axi_awqos,
    output wire [`AXI4_REGION_WIDTH -1:0]    ddr_axi_awregion,
    output wire [`AXI4_USER_WIDTH   -1:0]    ddr_axi_awuser,
    output wire                              ddr_axi_awvalid,
    input  wire                              ddr_axi_awready,
    output wire  [`AXI4_ID_WIDTH     -1:0]    ddr_axi_wid,
    output wire  [`AXI4_DATA_WIDTH   -1:0]    ddr_axi_wdata,
    output wire  [`AXI4_STRB_WIDTH   -1:0]    ddr_axi_wstrb,
    output wire                               ddr_axi_wlast,
    output wire  [`AXI4_USER_WIDTH   -1:0]    ddr_axi_wuser,
    output wire                               ddr_axi_wvalid,
    input  wire                               ddr_axi_wready,
    output wire  [`AXI4_ID_WIDTH     -1:0]    ddr_axi_arid,
    output wire  [`AXI4_ADDR_WIDTH   -1:0]    ddr_axi_araddr,
    output wire  [`AXI4_LEN_WIDTH    -1:0]    ddr_axi_arlen,
    output wire  [`AXI4_SIZE_WIDTH   -1:0]    ddr_axi_arsize,
    output wire  [`AXI4_BURST_WIDTH  -1:0]    ddr_axi_arburst,
    output wire                               ddr_axi_arlock,
    output wire  [`AXI4_CACHE_WIDTH  -1:0]    ddr_axi_arcache,
    output wire  [`AXI4_PROT_WIDTH   -1:0]    ddr_axi_arprot,
    output wire  [`AXI4_QOS_WIDTH    -1:0]    ddr_axi_arqos,
    output wire  [`AXI4_REGION_WIDTH -1:0]    ddr_axi_arregion,
    output wire  [`AXI4_USER_WIDTH   -1:0]    ddr_axi_aruser,
    output wire                               ddr_axi_arvalid,
    input  wire                               ddr_axi_arready,
    input  wire  [`AXI4_ID_WIDTH     -1:0]    ddr_axi_rid,
    input  wire  [`AXI4_DATA_WIDTH   -1:0]    ddr_axi_rdata,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    ddr_axi_rresp,
    input  wire                               ddr_axi_rlast,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    ddr_axi_ruser,
    input  wire                               ddr_axi_rvalid,
    output wire                               ddr_axi_rready,
    input  wire  [`AXI4_ID_WIDTH     -1:0]    ddr_axi_bid,
    input  wire  [`AXI4_RESP_WIDTH   -1:0]    ddr_axi_bresp,
    input  wire  [`AXI4_USER_WIDTH   -1:0]    ddr_axi_buser,
    input  wire                               ddr_axi_bvalid,
    output wire                               ddr_axi_bready, 
    input  wire                               ddr_ready

`ifdef PITONSYS_PCIE_DMA
    ,
    input                                pcie_dma_axi_clk,
    input                                pcie_dma_axi_resetn,
    input  [`AXI4_ID_WIDTH     -1:0]     pcie_dma_axi_awid,
    input  [`AXI4_ADDR_WIDTH   -1:0]     pcie_dma_axi_awaddr,
    input  [`AXI4_LEN_WIDTH    -1:0]     pcie_dma_axi_awlen,
    input  [`AXI4_SIZE_WIDTH   -1:0]     pcie_dma_axi_awsize,
    input  [`AXI4_BURST_WIDTH  -1:0]     pcie_dma_axi_awburst,
    input                                pcie_dma_axi_awlock,
    input  [`AXI4_CACHE_WIDTH  -1:0]     pcie_dma_axi_awcache,
    input  [`AXI4_PROT_WIDTH   -1:0]     pcie_dma_axi_awprot,
    input  [`AXI4_QOS_WIDTH    -1:0]     pcie_dma_axi_awqos,
    input  [`AXI4_REGION_WIDTH -1:0]     pcie_dma_axi_awregion,
    input  [`AXI4_USER_WIDTH   -1:0]     pcie_dma_axi_awuser,
    input                                pcie_dma_axi_awvalid,
    output                               pcie_dma_axi_awready,
    input   [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_wid,
    input   [`AXI4_DATA_WIDTH   -1:0]    pcie_dma_axi_wdata,
    input   [`AXI4_STRB_WIDTH   -1:0]    pcie_dma_axi_wstrb,
    input                                pcie_dma_axi_wlast,
    input   [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_wuser,
    input                                pcie_dma_axi_wvalid,
    output                               pcie_dma_axi_wready,
    input   [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_arid,
    input   [`AXI4_ADDR_WIDTH   -1:0]    pcie_dma_axi_araddr,
    input   [`AXI4_LEN_WIDTH    -1:0]    pcie_dma_axi_arlen,
    input   [`AXI4_SIZE_WIDTH   -1:0]    pcie_dma_axi_arsize,
    input   [`AXI4_BURST_WIDTH  -1:0]    pcie_dma_axi_arburst,
    input                                pcie_dma_axi_arlock,
    input   [`AXI4_CACHE_WIDTH  -1:0]    pcie_dma_axi_arcache,
    input   [`AXI4_PROT_WIDTH   -1:0]    pcie_dma_axi_arprot,
    input   [`AXI4_QOS_WIDTH    -1:0]    pcie_dma_axi_arqos,
    input   [`AXI4_REGION_WIDTH -1:0]    pcie_dma_axi_arregion,
    input   [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_aruser,
    input                                pcie_dma_axi_arvalid,
    output                               pcie_dma_axi_arready,
    output  [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_rid,
    output  [`AXI4_DATA_WIDTH   -1:0]    pcie_dma_axi_rdata,
    output  [`AXI4_RESP_WIDTH   -1:0]    pcie_dma_axi_rresp,
    output                               pcie_dma_axi_rlast,
    output  [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_ruser,
    output                               pcie_dma_axi_rvalid,
    input                                pcie_dma_axi_rready,
    output  [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_bid,
    output  [`AXI4_RESP_WIDTH   -1:0]    pcie_dma_axi_bresp,
    output  [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_buser,
    output                               pcie_dma_axi_bvalid,
    input                                pcie_dma_axi_bready
`endif // PITONSYS_PCIE_DMA
`endif // ifndef F1_BOARD
`endif // ifdef PITON_FPGA_MC_DDR
`endif // endif PITONSYS_NO_MC

`ifdef PITONSYS_IOCTRL
`ifdef PITONSYS_UART
    ,
    output                                      uart_tx,
    input                                       uart_rx
`ifdef PITONSYS_UART_CTS
    ,
    input                                       uart_ctsn, 
    output                                      uart_rtsn 
`endif
`ifdef PITONSYS_UART2
    ,
    output                                      uart2_tx,
    input                                       uart2_rx
`ifdef PITONSYS_UART_CTS
    ,
    input                                       uart2_ctsn, 
    output                                      uart2_rtsn 
`endif
`endif //ifdef PITONSYS_UART2
`ifdef PITONSYS_UART_BOOT
    ,
    input                                       uart_boot_en,
    input                                       uart_timeout_en
`endif // endif PITONSYS_UART_BOOT
`endif // endif PITONSYS_UART

`ifdef PITONSYS_SPI
    ,
    input                                       sd_clk,
    input                                       sd_cd,
    output                                      sd_reset,
    output                                      sd_clk_out,
    inout                                       sd_cmd,
    inout   [3:0]                               sd_dat
`endif // endif PITONSYS_SPI
`ifdef PITON_FPGA_ETHERNETLITE
    ,
    input                                       net_axi_clk,
    output                                      net_phy_rst_n,

    input                                       net_phy_tx_clk,
    output                                      net_phy_tx_en,
    output  [3 : 0]                             net_phy_tx_data,

    input                                       net_phy_rx_clk,
    input                                       net_phy_dv,
    input  [3 : 0]                              net_phy_rx_data,
    input                                       net_phy_rx_er,

    inout                                       net_phy_mdio_io,
    output                                      net_phy_mdc
`endif // PITON_FPGA_ETHERNETLITE
`endif // endif PITONSYS_IO_CTRL
`ifdef PITON_ARIANE
    ,
    // Debug
    output                                      ndmreset_o,    // non-debug module reset
    output                                      dmactive_o,    // debug module is active
    output [`PITON_NUM_TILES-1:0]                     debug_req_o,   // async debug request
    input  [`PITON_NUM_TILES-1:0]                     unavailable_i, // communicate whether the hart is unavailable (e.g.: power down)
    // JTAG
    input                                       tck_i,
    input                                       tms_i,
    input                                       trst_ni,
    input                                       td_i,
    output                                      td_o,
    output                                      tdo_oe_o
    `ifndef PITON_RVIC
    ,
    // CLINT
    input                                              rtc_i,         // Real-time clock in (usually 32.768 kHz)
    output [`PITON_NUM_TILES-1:0]                     timer_irq_o,   // Timer interrupts
    output [`PITON_NUM_TILES-1:0]                     ipi_o,         // software interrupt (a.k.a inter-process-interrupt)
    // PLIC
    output [`PITON_NUM_TILES*2-1:0]                   irq_o          // level sensitive IR lines, mip & sip (async)
    `endif
`endif
);

///////////////////////
// Type declarations //
///////////////////////

reg                                             io_ctrl_rst_n;

`ifndef PITONSYS_IOCTRL
wire                                            uart_boot_en;
wire                                            uart_timeout_en;
`else // ifdef PITONSYS_IOCTRL
`ifndef PITONSYS_UART
wire                                            uart_boot_en;
wire                                            uart_timeout_en;
`else // ifdef PITONSYS_UART
`ifndef PITONSYS_UART_BOOT
wire                                            uart_boot_en;
wire                                            uart_timeout_en;
`endif // endif PITONSYS_UART_BOOT
`endif // endif PITONSYS_UART
`endif // endif PITONSYS_IOCTRL

`ifdef PITONSYS_PCIE_DMA
`ifndef F1_BOARD
wire                               pcie_dma_axi_clk;
wire                               pcie_dma_axi_resetn;
wire [`AXI4_ID_WIDTH     -1:0]     pcie_dma_axi_awid;
wire [`AXI4_ADDR_WIDTH   -1:0]     pcie_dma_axi_awaddr;
wire [`AXI4_LEN_WIDTH    -1:0]     pcie_dma_axi_awlen;
wire [`AXI4_SIZE_WIDTH   -1:0]     pcie_dma_axi_awsize;
wire [`AXI4_BURST_WIDTH  -1:0]     pcie_dma_axi_awburst;
wire                               pcie_dma_axi_awlock;
wire [`AXI4_CACHE_WIDTH  -1:0]     pcie_dma_axi_awcache;
wire [`AXI4_PROT_WIDTH   -1:0]     pcie_dma_axi_awprot;
wire [`AXI4_QOS_WIDTH    -1:0]     pcie_dma_axi_awqos;
wire [`AXI4_REGION_WIDTH -1:0]     pcie_dma_axi_awregion;
wire [`AXI4_USER_WIDTH   -1:0]     pcie_dma_axi_awuser;
wire                               pcie_dma_axi_awvalid;
wire                               pcie_dma_axi_awready;
wire  [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_wid;
wire  [`AXI4_DATA_WIDTH   -1:0]    pcie_dma_axi_wdata;
wire  [`AXI4_STRB_WIDTH   -1:0]    pcie_dma_axi_wstrb;
wire                               pcie_dma_axi_wlast;
wire  [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_wuser;
wire                               pcie_dma_axi_wvalid;
wire                               pcie_dma_axi_wready;
wire  [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_arid;
wire  [`AXI4_ADDR_WIDTH   -1:0]    pcie_dma_axi_araddr;
wire  [`AXI4_LEN_WIDTH    -1:0]    pcie_dma_axi_arlen;
wire  [`AXI4_SIZE_WIDTH   -1:0]    pcie_dma_axi_arsize;
wire  [`AXI4_BURST_WIDTH  -1:0]    pcie_dma_axi_arburst;
wire                               pcie_dma_axi_arlock;
wire  [`AXI4_CACHE_WIDTH  -1:0]    pcie_dma_axi_arcache;
wire  [`AXI4_PROT_WIDTH   -1:0]    pcie_dma_axi_arprot;
wire  [`AXI4_QOS_WIDTH    -1:0]    pcie_dma_axi_arqos;
wire  [`AXI4_REGION_WIDTH -1:0]    pcie_dma_axi_arregion;
wire  [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_aruser;
wire                               pcie_dma_axi_arvalid;
wire                               pcie_dma_axi_arready;
wire  [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_rid;
wire  [`AXI4_DATA_WIDTH   -1:0]    pcie_dma_axi_rdata;
wire  [`AXI4_RESP_WIDTH   -1:0]    pcie_dma_axi_rresp;
wire                               pcie_dma_axi_rlast;
wire  [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_ruser;
wire                               pcie_dma_axi_rvalid;
wire                               pcie_dma_axi_rready;
wire  [`AXI4_ID_WIDTH     -1:0]    pcie_dma_axi_bid;
wire  [`AXI4_RESP_WIDTH   -1:0]    pcie_dma_axi_bresp;
wire  [`AXI4_USER_WIDTH   -1:0]    pcie_dma_axi_buser;
wire                               pcie_dma_axi_bvalid;
wire                               pcie_dma_axi_bready;
`endif // F1_BOARD
`endif // PITONSYS_PCIE_DMA

`ifdef PITONSYS_PCIE_CFG
wire                               pcie_cfg_axi_clk;
wire                               pcie_cfg_axi_resetn;
wire [`AXIL_ADDR_WIDTH   -1:0]     pcie_cfg_axi_awaddr;
wire [`AXIL_PROT_WIDTH   -1:0]     pcie_cfg_axi_awprot;
wire                               pcie_cfg_axi_awvalid;
wire                               pcie_cfg_axi_awready;
wire  [`AXIL_DATA_WIDTH   -1:0]    pcie_cfg_axi_wdata;
wire  [`AXIL_STRB_WIDTH   -1:0]    pcie_cfg_axi_wstrb;
wire                               pcie_cfg_axi_wvalid;
wire                               pcie_cfg_axi_wready;
wire                               pcie_cfg_axi_bvalid;
wire  [`AXIL_RESP_WIDTH   -1:0]    pcie_cfg_axi_bresp;
wire                               pcie_cfg_axi_bready;
wire  [`AXIL_ADDR_WIDTH   -1:0]    pcie_cfg_axi_araddr;
wire  [`AXIL_PROT_WIDTH   -1:0]    pcie_cfg_axi_arprot;
wire                               pcie_cfg_axi_arvalid;
wire                               pcie_cfg_axi_arready;
wire  [`AXIL_DATA_WIDTH   -1:0]    pcie_cfg_axi_rdata;
wire  [`AXIL_RESP_WIDTH   -1:0]    pcie_cfg_axi_rresp;
wire                               pcie_cfg_axi_rvalid;
wire                               pcie_cfg_axi_rready;
`endif // PITONSYS_PCIE_CFG

wire                                            cpu_mem_traffic;
wire                                            chip_filter_noc2_valid;
wire    [`NOC_DATA_WIDTH-1:0]                   chip_filter_noc2_data;
wire                                            filter_chip_noc2_ready;
wire                                            filter_chip_noc3_valid;
wire    [`NOC_DATA_WIDTH-1:0]                   filter_chip_noc3_data;
wire                                            chip_filter_noc3_ready;


wire                                            test_good_end;
wire                                            test_bad_end;

<%
for i in range(len(devices)):
    if devices[i]["virtual"]:
            continue
# wires for the noc2 crossbar
    print("""
wire [`DATA_WIDTH-1:0] %s_buf_xbar_noc2_data;
wire                   %s_buf_xbar_noc2_valid;
wire                   %s_buf_xbar_noc2_yummy;
wire [`DATA_WIDTH-1:0] xbar_buf_%s_noc2_data;
wire                   xbar_buf_%s_noc2_valid;
wire                   xbar_buf_%s_noc2_yummy;

wire [`DATA_WIDTH-1:0] buf_%s_noc2_data;
wire                   buf_%s_noc2_valid;
wire                   %s_buf_noc2_ready;

wire [`DATA_WIDTH-1:0] %s_buf_noc2_data;
wire                   %s_buf_noc2_valid;
wire                   buf_%s_noc2_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"]))

# wires for the noc3 crossbar
    print("""
wire [`DATA_WIDTH-1:0] %s_buf_xbar_noc3_data;
wire                   %s_buf_xbar_noc3_valid;
wire                   %s_buf_xbar_noc3_yummy;
wire [`DATA_WIDTH-1:0] xbar_buf_%s_noc3_data;
wire                   xbar_buf_%s_noc3_valid;
wire                   xbar_buf_%s_noc3_yummy;

wire [`DATA_WIDTH-1:0] buf_%s_noc3_data;
wire                   buf_%s_noc3_valid;
wire                   %s_buf_noc3_ready;

wire [`DATA_WIDTH-1:0] %s_buf_noc3_data;
wire                   %s_buf_noc3_valid;
wire                   buf_%s_noc3_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"]))
    # if the device doesn't have a noc2 input, tie off unused wires
    if not (devices[i]["noc2_in"]):
        print("""
assign %s_buf_noc2_data = `DATA_WIDTH'b0;
assign %s_buf_noc2_valid = 1'b0;
assign %s_buf_noc3_ready = 1'b0;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"]))
    # otherwise, give it a set of packet filter wires except for the chip (for now)
    elif (i > 0):
        print("""
wire [`DATA_WIDTH-1:0]            %s_filter_noc2_data;
wire                              %s_filter_noc2_valid;
wire                              filter_%s_noc2_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"]))
        print("""
wire [`DATA_WIDTH-1:0]             filter_%s_noc3_data;
wire                               filter_%s_noc3_valid;
wire                               %s_filter_noc3_ready;
""" % (devices[i]["name"], devices[i]["name"], devices[i]["name"]))

%>

/////////////////////////
// Combinational Logic //
/////////////////////////

// Currently NoC 1 from chipset to interface is not used
// by any chipset implementation
assign chipset_intf_data_noc1 = {`NOC_DATA_WIDTH{1'b0}};
assign chipset_intf_val_noc1 = 1'b0;

// Currently NoC 3 from interface to chipset is not used
// by any chipset implementation
assign intf_chipset_rdy_noc3 = 1'b0;
assign chip_buf_noc3_valid = 1'b0;
assign chip_buf_noc3_data = {`NOC_DATA_WIDTH{1'b0}};

`ifdef PITONSYS_NO_MC
`ifndef PITON_FPGA_SYNTH
    // Tie off splitter memory interface
    assign mem_buf_noc2_ready = 1'b0;
    assign mem_buf_noc3_valid = 1'b0;
    assign mem_buf_noc3_data = {`NOC_DATA_WIDTH{1'b0}};
`endif // endif PITON_FPGA_SYNTH
`endif // endif PITONSYS_NO_MC


`ifdef PITONSYS_IOCTRL
    always @ * begin
    io_ctrl_rst_n = chipset_rst_n;
    `ifndef PITONSYS_NO_MC
    `ifdef PITON_FPGA_MC_DDR
        // Reset I/O ctrl as long as DRAM ctrl is not reset
        // and not calibrated or initialized
        io_ctrl_rst_n = io_ctrl_rst_n & init_calib_complete;
    `endif // endif PITON_FPGA_MC_DDR
    `endif // PITONSYS_NO_MC
    end
`endif // endif PITONSYS_IOCTRL

`ifndef PITONSYS_IOCTRL
    assign uart_boot_en = 1'b0;
    assign uart_timeout_en = 1'b0;
`else // ifdef PITONSYS_IOCTRL
    `ifndef PITONSYS_UART
        assign uart_boot_en = 1'b0;
        assign uart_timeout_en = 1'b0;
    `else // ifdef PITONSYS_UART
        `ifndef PITONSYS_UART_BOOT
            assign uart_boot_en = 1'b0;
            assign uart_timeout_en = 1'b0;
        `endif // endif PITONSYS_UART_BOOT
    `endif // endif PITONSYS_UART
`endif // endif PITONSYS_IOCTRL

//////////////////////////
// Sub-module Instances //
//////////////////////////
`ifdef PITONSYS_IOCTRL
    assign cpu_mem_traffic = test_start | (~uart_boot_en);
`else
    assign cpu_mem_traffic = 1'b1;
`endif

assign chipset_intf_val_noc2 = buf_chip_noc2_valid;
assign chipset_intf_data_noc2 = buf_chip_noc2_data;
assign chip_buf_noc2_ready = chipset_intf_rdy_noc2;

assign chip_filter_noc2_valid = intf_chipset_val_noc2;
assign chip_filter_noc2_data = intf_chipset_data_noc2;
assign intf_chipset_rdy_noc2    = filter_chip_noc2_ready & cpu_mem_traffic;

// NoC 3
assign chipset_intf_val_noc3    = cpu_mem_traffic & filter_chip_noc3_valid;
assign chipset_intf_data_noc3   = filter_chip_noc3_data;

assign chip_filter_noc3_ready  = cpu_mem_traffic ? chipset_intf_rdy_noc3 : 1'b1;

`ifdef PITONSYS_UART_BOOT
test_end_checker test_end_checker(
    .clk                    (chipset_clk),
    .rst_n                  (chipset_rst_n),

    .src_checker_noc2_val   (chip_filter_noc2_valid),
    .src_checker_noc2_data  (chip_filter_noc2_data),
    .src_checker_noc2_rdy   (filter_chip_noc2_ready),

    .uart_boot_en           (uart_boot_en),
    .test_good_end          (test_good_end),
    .test_bad_end           (test_bad_end)
);
`else
    assign test_good_end = 1'b0;
    assign test_bad_end = 1'b0;
`endif

<%

# need to figure out number of invalid access signals
tmpNum=0
for i in range(len(devices)):
    if devices[i]["noc2_in"]:
        tmpNum +=1

if tmpNum:
    print("""
wire [%d-1:0] invalid_access;
assign invalid_access_o = |invalid_access;
""" % (tmpNum))
else:
    print("""
assign invalid_access_o = 1'b0;
""")

tmpIdx=0
for i in range(len(devices)):
    if devices[i]["noc2_in"]:
        print("""
packet_filter %s_packet_filter(
    .clk(chipset_clk),
    .rst_n(chipset_rst_n),
    // need to connect this to a LED
    .invalid_access_o(invalid_access[%d]),

    // noc2 to filter wires
    .noc2_filter_val(%s_filter_noc2_valid),
    .noc2_filter_data(%s_filter_noc2_data),
    .filter_noc2_rdy(filter_%s_noc2_ready),

    // filter to noc3 wires
    .filter_noc3_val(filter_%s_noc3_valid),
    .filter_noc3_data(filter_%s_noc3_data),
    .noc3_filter_rdy(%s_filter_noc3_ready),

    // filter to xbar wires
    .filter_xbar_val(%s_buf_noc2_valid),
    .filter_xbar_data(%s_buf_noc2_data),
    .xbar_filter_rdy(buf_%s_noc2_ready),

    // xbar to filter wires
    .xbar_filter_val(buf_%s_noc3_valid),
    .xbar_filter_data(buf_%s_noc3_data),
    .filter_xbar_rdy(%s_buf_noc3_ready),

    .uart_boot_en(uart_boot_en)
);
""" % (devices[i]["name"], tmpIdx,
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"],
       devices[i]["name"], devices[i]["name"], devices[i]["name"]))
        tmpIdx+=1
%>

<%

xbartemplate = r'''
io_xbar_top_wrap io_xbar_noc2 (
    .clk                (chipset_clk),
    .reset_in           (~chipset_rst_n),

`ifdef PITON_MULTICHIP
    .myChipID                   (chipid),    // the first chip
`else
    .myChipID                   (14'b10000000000000),
`endif
    .myLocX                     (8'b0),  // not used
    .myLocY                     (8'b0),  // not used

'''

for i in range(len(devices)):
            if devices[i]["virtual"]:
                        continue
            xbartemplate += "    .dataIn_%d(%s_buf_xbar_noc2_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validIn_%d(%s_buf_xbar_noc2_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyIn_%d(%s_buf_xbar_noc2_yummy),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .dataOut_%d(xbar_buf_%s_noc2_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validOut_%d(xbar_buf_%s_noc2_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyOut_%d(xbar_buf_%s_noc2_yummy),\n\n" % (devices[i]["portnum"], devices[i]["name"])

xbartemplate = xbartemplate[:-3] + r'''
);'''

print(xbartemplate)

xbartemplate = r'''
io_xbar_top_wrap io_xbar_noc3 (
    .clk                (chipset_clk),
    .reset_in           (~chipset_rst_n),

`ifdef PITON_MULTICHIP
    .myChipID                   (chipid),    // the first chip
`else
    .myChipID                   (14'b10000000000000),
`endif
    .myLocX                     (8'b0),  // not used
    .myLocY                     (8'b0),  // not used

'''

for i in range(len(devices)):
            if devices[i]["virtual"]:
                        continue

            xbartemplate += "    .dataIn_%d(%s_buf_xbar_noc3_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validIn_%d(%s_buf_xbar_noc3_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyIn_%d(%s_buf_xbar_noc3_yummy),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .dataOut_%d(xbar_buf_%s_noc3_data),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .validOut_%d(xbar_buf_%s_noc3_valid),\n"  % (devices[i]["portnum"], devices[i]["name"])
            xbartemplate += "    .yummyOut_%d(xbar_buf_%s_noc3_yummy),\n\n" % (devices[i]["portnum"], devices[i]["name"])

xbartemplate = xbartemplate[:-3] + r'''
    ,
    .thanksIn_%d()
);''' % (DYNAMIC_NODE_PORT - 1)


print(xbartemplate)

for i in range(len(devices)):
    if devices[i]["virtual"]:  
        continue

    valrdy_credit_template = r'''
valrdy_to_credit noc2_%s_to_xbar (
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(%s_buf_noc2_data),
      .valid_in(%s_buf_noc2_valid),
      .ready_in(buf_%s_noc2_ready),

      .data_out(%s_buf_xbar_noc2_data),           // Data
      .valid_out(%s_buf_xbar_noc2_valid),       // Val signal
      .yummy_out(xbar_buf_%s_noc2_yummy)    // Yummy signal
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
        devices[i]["name"], devices[i]["name"], devices[i]["name"])

    credit_valrdy_template = r'''
credit_to_valrdy noc2_xbar_to_%s(
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(xbar_buf_%s_noc2_data),
      .valid_in(xbar_buf_%s_noc2_valid),
      .yummy_in(%s_buf_xbar_noc2_yummy),

      .data_out(buf_%s_noc2_data),           // Data
      .valid_out(buf_%s_noc2_valid),       // Val signal from dynamic network to processor
      .ready_out(%s_buf_noc2_ready)    // Rdy signal from processor to dynamic network
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
         devices[i]["name"], devices[i]["name"], devices[i]["name"])

    print(valrdy_credit_template)
    print(credit_valrdy_template)

    valrdy_credit_template = r'''
valrdy_to_credit noc3_%s_to_xbar (
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(%s_buf_noc3_data),
      .valid_in(%s_buf_noc3_valid),
      .ready_in(buf_%s_noc3_ready),

      .data_out(%s_buf_xbar_noc3_data),           // Data
      .valid_out(%s_buf_xbar_noc3_valid),       // Val signal
      .yummy_out(xbar_buf_%s_noc3_yummy)    // Yummy signal
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
        devices[i]["name"], devices[i]["name"], devices[i]["name"])

    credit_valrdy_template = r'''
credit_to_valrdy noc3_xbar_to_%s(
      .clk(chipset_clk),
      .reset(~chipset_rst_n),

      .data_in(xbar_buf_%s_noc3_data),
      .valid_in(xbar_buf_%s_noc3_valid),
      .yummy_in(%s_buf_xbar_noc3_yummy),

      .data_out(buf_%s_noc3_data),           // Data
      .valid_out(buf_%s_noc3_valid),       // Val signal from dynamic network to processor
      .ready_out(%s_buf_noc3_ready)    // Rdy signal from processor to dynamic network
);''' % (devices[i]["name"], devices[i]["name"], devices[i]["name"], devices[i]["name"],
         devices[i]["name"], devices[i]["name"], devices[i]["name"])

    print(valrdy_credit_template)
    print(credit_valrdy_template)
%>

`ifdef PITONSYS_PCIE
pcie_controller pcie_controller(
    .pcie_clk_p(pcie_clk_p), 
    .pcie_clk_n(pcie_clk_n), 
    .pcie_rst_n(pcie_rst_n),
    .pcie_txp(pcie_txp), 
    .pcie_txn(pcie_txn), 
    .pcie_rxp(pcie_rxp), 
    .pcie_rxn(pcie_rxn)

`ifdef PITONSYS_PCIE_DMA
    ,
    .pcie_dma_axi_clk(pcie_dma_axi_clk), 
    .pcie_dma_axi_resetn(pcie_dma_axi_resetn), 
    .pcie_dma_axi_awid(pcie_dma_axi_awid),
    .pcie_dma_axi_awaddr(pcie_dma_axi_awaddr),
    .pcie_dma_axi_awlen(pcie_dma_axi_awlen),
    .pcie_dma_axi_awsize(pcie_dma_axi_awsize),
    .pcie_dma_axi_awburst(pcie_dma_axi_awburst),
    .pcie_dma_axi_awlock(pcie_dma_axi_awlock),
    .pcie_dma_axi_awcache(pcie_dma_axi_awcache),
    .pcie_dma_axi_awprot(pcie_dma_axi_awprot),
    .pcie_dma_axi_awqos(pcie_dma_axi_awqos),
    .pcie_dma_axi_awregion(pcie_dma_axi_awregion),
    .pcie_dma_axi_awuser(pcie_dma_axi_awuser),
    .pcie_dma_axi_awvalid(pcie_dma_axi_awvalid),
    .pcie_dma_axi_awready(pcie_dma_axi_awready),
    .pcie_dma_axi_wid(pcie_dma_axi_wid),
    .pcie_dma_axi_wdata(pcie_dma_axi_wdata),
    .pcie_dma_axi_wstrb(pcie_dma_axi_wstrb),
    .pcie_dma_axi_wlast(pcie_dma_axi_wlast),
    .pcie_dma_axi_wuser(pcie_dma_axi_wuser),
    .pcie_dma_axi_wvalid(pcie_dma_axi_wvalid),
    .pcie_dma_axi_wready(pcie_dma_axi_wready),
    .pcie_dma_axi_arid(pcie_dma_axi_arid),
    .pcie_dma_axi_araddr(pcie_dma_axi_araddr),
    .pcie_dma_axi_arlen(pcie_dma_axi_arlen),
    .pcie_dma_axi_arsize(pcie_dma_axi_arsize),
    .pcie_dma_axi_arburst(pcie_dma_axi_arburst),
    .pcie_dma_axi_arlock(pcie_dma_axi_arlock),
    .pcie_dma_axi_arcache(pcie_dma_axi_arcache),
    .pcie_dma_axi_arprot(pcie_dma_axi_arprot),
    .pcie_dma_axi_arqos(pcie_dma_axi_arqos),
    .pcie_dma_axi_arregion(pcie_dma_axi_arregion),
    .pcie_dma_axi_aruser(pcie_dma_axi_aruser),
    .pcie_dma_axi_arvalid(pcie_dma_axi_arvalid),
    .pcie_dma_axi_arready(pcie_dma_axi_arready),
    .pcie_dma_axi_rid(pcie_dma_axi_rid),
    .pcie_dma_axi_rdata(pcie_dma_axi_rdata),
    .pcie_dma_axi_rresp(pcie_dma_axi_rresp),
    .pcie_dma_axi_rlast(pcie_dma_axi_rlast),
    .pcie_dma_axi_ruser(pcie_dma_axi_ruser),
    .pcie_dma_axi_rvalid(pcie_dma_axi_rvalid),
    .pcie_dma_axi_rready(pcie_dma_axi_rready),
    .pcie_dma_axi_bid(pcie_dma_axi_bid),
    .pcie_dma_axi_bresp(pcie_dma_axi_bresp),
    .pcie_dma_axi_buser(pcie_dma_axi_buser),
    .pcie_dma_axi_bvalid(pcie_dma_axi_bvalid),
    .pcie_dma_axi_bready(pcie_dma_axi_bready)
`endif // PITONSYS_PCIE_DMA
`ifdef PITONSYS_PCIE_CFG
    ,
    .pcie_cfg_axi_clk(pcie_cfg_axi_clk),
    .pcie_cfg_axi_resetn(pcie_cfg_axi_resetn),
    .pcie_cfg_axi_awaddr(pcie_cfg_axi_awaddr), 
    .pcie_cfg_axi_awprot(pcie_cfg_axi_awprot), 
    .pcie_cfg_axi_awvalid(pcie_cfg_axi_awvalid),
    .pcie_cfg_axi_awready(pcie_cfg_axi_awready), 
    .pcie_cfg_axi_wdata(pcie_cfg_axi_wdata),
    .pcie_cfg_axi_wstrb(pcie_cfg_axi_wstrb),
    .pcie_cfg_axi_wvalid(pcie_cfg_axi_wvalid),
    .pcie_cfg_axi_wready(pcie_cfg_axi_wready),
    .pcie_cfg_axi_bvalid(pcie_cfg_axi_bvalid),
    .pcie_cfg_axi_bresp(pcie_cfg_axi_bresp),
    .pcie_cfg_axi_bready(pcie_cfg_axi_bready),
    .pcie_cfg_axi_araddr(pcie_cfg_axi_araddr),
    .pcie_cfg_axi_arprot(pcie_cfg_axi_arprot),
    .pcie_cfg_axi_arvalid(pcie_cfg_axi_arvalid),
    .pcie_cfg_axi_arready(pcie_cfg_axi_arready),
    .pcie_cfg_axi_rdata(pcie_cfg_axi_rdata),
    .pcie_cfg_axi_rresp(pcie_cfg_axi_rresp),
    .pcie_cfg_axi_rvalid(pcie_cfg_axi_rvalid),
    .pcie_cfg_axi_rready(pcie_cfg_axi_rready)
`endif // PITONSYS_PCIE_CFG
);
`endif // PITONSYS_PCIE

`ifdef PITONSYS_PCIE_CFG
pcie_cfg pcie_cfg(
    .sys_clk(chipset_clk),

    .pcie_cfg_axi_clk(pcie_cfg_axi_clk),
    .pcie_cfg_axi_resetn(pcie_cfg_axi_resetn),
    .pcie_cfg_axi_awaddr(pcie_cfg_axi_awaddr), 
    .pcie_cfg_axi_awprot(pcie_cfg_axi_awprot), 
    .pcie_cfg_axi_awvalid(pcie_cfg_axi_awvalid),
    .pcie_cfg_axi_awready(pcie_cfg_axi_awready), 
    .pcie_cfg_axi_wdata(pcie_cfg_axi_wdata),
    .pcie_cfg_axi_wstrb(pcie_cfg_axi_wstrb),
    .pcie_cfg_axi_wvalid(pcie_cfg_axi_wvalid),
    .pcie_cfg_axi_wready(pcie_cfg_axi_wready),
    .pcie_cfg_axi_bvalid(pcie_cfg_axi_bvalid),
    .pcie_cfg_axi_bresp(pcie_cfg_axi_bresp),
    .pcie_cfg_axi_bready(pcie_cfg_axi_bready),
    .pcie_cfg_axi_araddr(pcie_cfg_axi_araddr),
    .pcie_cfg_axi_arprot(pcie_cfg_axi_arprot),
    .pcie_cfg_axi_arvalid(pcie_cfg_axi_arvalid),
    .pcie_cfg_axi_arready(pcie_cfg_axi_arready),
    .pcie_cfg_axi_rdata(pcie_cfg_axi_rdata),
    .pcie_cfg_axi_rresp(pcie_cfg_axi_rresp),
    .pcie_cfg_axi_rvalid(pcie_cfg_axi_rvalid),
    .pcie_cfg_axi_rready(pcie_cfg_axi_rready),

    .pcie_cfg_rst_out_n(pcie_cfg_rst_out_n),
    .pcie_cfg_sw_out(pcie_cfg_sw_out)
);

`endif // PITONSYS_PCIE_CFG


`ifndef PITONSYS_NO_MC
// Memory controller.  Either uses "fake" simulated
// memory controller or FPGA memory controllers
`ifdef PITON_FPGA_MC_DDR
    mc_top mc_top(
        .sys_clk(chipset_clk),
        .sys_rst_n(chipset_rst_n),

        .mc_flit_in_val(buf_mem_noc2_valid),
        .mc_flit_in_data(buf_mem_noc2_data),
        .mc_flit_in_rdy(mem_buf_noc2_ready),

        .mc_flit_out_val(mem_buf_noc3_valid),
        .mc_flit_out_data(mem_buf_noc3_data),
        .mc_flit_out_rdy(buf_mem_noc3_ready),

        .uart_boot_en(uart_boot_en),
        .init_calib_complete_out(init_calib_complete),

    `ifdef PITONSYS_PCIE_DMA
        .pcie_dma_axi_clk(pcie_dma_axi_clk),
        .pcie_dma_axi_resetn(pcie_dma_axi_resetn),
        .pcie_dma_axi_awid(pcie_dma_axi_awid),
        .pcie_dma_axi_awaddr(pcie_dma_axi_awaddr),
        .pcie_dma_axi_awlen(pcie_dma_axi_awlen),
        .pcie_dma_axi_awsize(pcie_dma_axi_awsize),
        .pcie_dma_axi_awburst(pcie_dma_axi_awburst),
        .pcie_dma_axi_awlock(pcie_dma_axi_awlock),
        .pcie_dma_axi_awcache(pcie_dma_axi_awcache),
        .pcie_dma_axi_awprot(pcie_dma_axi_awprot),
        .pcie_dma_axi_awqos(pcie_dma_axi_awqos),
        .pcie_dma_axi_awregion(pcie_dma_axi_awregion),
        .pcie_dma_axi_awuser(pcie_dma_axi_awuser),
        .pcie_dma_axi_awvalid(pcie_dma_axi_awvalid),
        .pcie_dma_axi_awready(pcie_dma_axi_awready),
        .pcie_dma_axi_wid(pcie_dma_axi_wid),
        .pcie_dma_axi_wdata(pcie_dma_axi_wdata),
        .pcie_dma_axi_wstrb(pcie_dma_axi_wstrb),
        .pcie_dma_axi_wlast(pcie_dma_axi_wlast),
        .pcie_dma_axi_wuser(pcie_dma_axi_wuser),
        .pcie_dma_axi_wvalid(pcie_dma_axi_wvalid),
        .pcie_dma_axi_wready(pcie_dma_axi_wready),
        .pcie_dma_axi_arid(pcie_dma_axi_arid),
        .pcie_dma_axi_araddr(pcie_dma_axi_araddr),
        .pcie_dma_axi_arlen(pcie_dma_axi_arlen),
        .pcie_dma_axi_arsize(pcie_dma_axi_arsize),
        .pcie_dma_axi_arburst(pcie_dma_axi_arburst),
        .pcie_dma_axi_arlock(pcie_dma_axi_arlock),
        .pcie_dma_axi_arcache(pcie_dma_axi_arcache),
        .pcie_dma_axi_arprot(pcie_dma_axi_arprot),
        .pcie_dma_axi_arqos(pcie_dma_axi_arqos),
        .pcie_dma_axi_arregion(pcie_dma_axi_arregion),
        .pcie_dma_axi_aruser(pcie_dma_axi_aruser),
        .pcie_dma_axi_arvalid(pcie_dma_axi_arvalid),
        .pcie_dma_axi_arready(pcie_dma_axi_arready),
        .pcie_dma_axi_rid(pcie_dma_axi_rid),
        .pcie_dma_axi_rdata(pcie_dma_axi_rdata),
        .pcie_dma_axi_rresp(pcie_dma_axi_rresp),
        .pcie_dma_axi_rlast(pcie_dma_axi_rlast),
        .pcie_dma_axi_ruser(pcie_dma_axi_ruser),
        .pcie_dma_axi_rvalid(pcie_dma_axi_rvalid),
        .pcie_dma_axi_rready(pcie_dma_axi_rready),
        .pcie_dma_axi_bid(pcie_dma_axi_bid),
        .pcie_dma_axi_bresp(pcie_dma_axi_bresp),
        .pcie_dma_axi_buser(pcie_dma_axi_buser),
        .pcie_dma_axi_bvalid(pcie_dma_axi_bvalid),
        .pcie_dma_axi_bready(pcie_dma_axi_bready),
    `endif // PITONSYS_PCIE_DMA

    `ifndef F1_BOARD
        `ifdef PITONSYS_DDR4
            .mc_clk_p(mc_clk_p),
            .mc_clk_n(mc_clk_n),
            .ddr_act_n(ddr_act_n),
            .ddr_bg(ddr_bg),
        `else // PITONSYS_DDR4
            .mc_clk(mc_clk),
            .ddr_cas_n(ddr_cas_n),
            .ddr_ras_n(ddr_ras_n),
            .ddr_we_n(ddr_we_n),
        `endif // PITONSYS_DDR4

            .ddr_addr(ddr_addr),
            .ddr_ba(ddr_ba),
            .ddr_ck_n(ddr_ck_n),
            .ddr_ck_p(ddr_ck_p),
            .ddr_cke(ddr_cke),
            .ddr_reset_n(ddr_reset_n),
            .ddr_dq(ddr_dq),
            .ddr_dqs_n(ddr_dqs_n),
            .ddr_dqs_p(ddr_dqs_p),
        `ifndef NEXYSVIDEO_BOARD
            .ddr_cs_n(ddr_cs_n),
        `endif // endif NEXYSVIDEO_BOARD
        `ifdef XUPP3R_BOARD
            .ddr_parity(ddr_parity),
        `else
            .ddr_dm(ddr_dm),
        `endif // XUPP3R_BOARD
            .ddr_odt(ddr_odt)
    `else // F1_BOARD
        .ddr_axi_clk(ddr_axi_clk),
        .ddr_axi_resetn(ddr_axi_resetn),
        .ddr_axi_awid(ddr_axi_awid),
        .ddr_axi_awaddr(ddr_axi_awaddr),
        .ddr_axi_awlen(ddr_axi_awlen),
        .ddr_axi_awsize(ddr_axi_awsize),
        .ddr_axi_awburst(ddr_axi_awburst),
        .ddr_axi_awlock(ddr_axi_awlock),
        .ddr_axi_awcache(ddr_axi_awcache),
        .ddr_axi_awprot(ddr_axi_awprot),
        .ddr_axi_awqos(ddr_axi_awqos),
        .ddr_axi_awregion(ddr_axi_awregion),
        .ddr_axi_awuser(ddr_axi_awuser),
        .ddr_axi_awvalid(ddr_axi_awvalid),
        .ddr_axi_awready(ddr_axi_awready),
        .ddr_axi_wid(ddr_axi_wid),
        .ddr_axi_wdata(ddr_axi_wdata),
        .ddr_axi_wstrb(ddr_axi_wstrb),
        .ddr_axi_wlast(ddr_axi_wlast),
        .ddr_axi_wuser(ddr_axi_wuser),
        .ddr_axi_wvalid(ddr_axi_wvalid),
        .ddr_axi_wready(ddr_axi_wready),
        .ddr_axi_arid(ddr_axi_arid),
        .ddr_axi_araddr(ddr_axi_araddr),
        .ddr_axi_arlen(ddr_axi_arlen),
        .ddr_axi_arsize(ddr_axi_arsize),
        .ddr_axi_arburst(ddr_axi_arburst),
        .ddr_axi_arlock(ddr_axi_arlock),
        .ddr_axi_arcache(ddr_axi_arcache),
        .ddr_axi_arprot(ddr_axi_arprot),
        .ddr_axi_arqos(ddr_axi_arqos),
        .ddr_axi_arregion(ddr_axi_arregion),
        .ddr_axi_aruser(ddr_axi_aruser),
        .ddr_axi_arvalid(ddr_axi_arvalid),
        .ddr_axi_arready(ddr_axi_arready),
        .ddr_axi_rid(ddr_axi_rid),
        .ddr_axi_rdata(ddr_axi_rdata),
        .ddr_axi_rresp(ddr_axi_rresp),
        .ddr_axi_rlast(ddr_axi_rlast),
        .ddr_axi_ruser(ddr_axi_ruser),
        .ddr_axi_rvalid(ddr_axi_rvalid),
        .ddr_axi_rready(ddr_axi_rready),
        .ddr_axi_bid(ddr_axi_bid),
        .ddr_axi_bresp(ddr_axi_bresp),
        .ddr_axi_buser(ddr_axi_buser),
        .ddr_axi_bvalid(ddr_axi_bvalid),
        .ddr_axi_bready(ddr_axi_bready), 
        .init_calib_complete(ddr_ready)
    `endif // F1_BOARD
    );

`else

`include "cross_module.tmp.h"

// Fake Memory Controller
fake_mem_ctrl fake_mem_ctrl(
    .clk                ( chipset_clk        ),
    .rst_n              ( chipset_rst_n      ),
    .noc_valid_in       ( buf_mem_noc2_valid ),
    .noc_data_in        ( buf_mem_noc2_data  ),
    .noc_ready_in       ( mem_buf_noc2_ready ),
    .noc_valid_out      ( mem_buf_noc3_valid ),
    .noc_data_out       ( mem_buf_noc3_data  ),
    .noc_ready_out      ( buf_mem_noc3_ready )
);

`endif // endif PITON_FPGA_MC_DDR

`else

`ifdef PITON_FPGA_BRAM_TEST

    fake_boot_ctrl  fake_boot_ctrl(
        .clk            ( chipset_clk        ),
        .rst_n          ( chipset_rst_n      ),

        .noc_valid_in   ( buf_mem_noc2_valid ),
        .noc_data_in    ( buf_mem_noc2_data  ),
        .noc_ready_in   ( mem_buf_noc2_ready ),

        .noc_valid_out  ( mem_buf_noc3_valid ),
        .noc_data_out   ( mem_buf_noc3_data  ),
        .noc_ready_out  ( buf_mem_noc3_ready )
    );

`elsif PITON_FPGA_BRAM_BOOT

    fake_boot_ctrl  fake_boot_ctrl(
        .clk            ( chipset_clk        ),
        .rst_n          ( chipset_rst_n      ),

        .noc_valid_in   ( buf_mem_noc2_valid ),
        .noc_data_in    ( buf_mem_noc2_data  ),
        .noc_ready_in   ( mem_buf_noc2_ready ),

        .noc_valid_out  ( mem_buf_noc3_valid ),
        .noc_data_out   ( mem_buf_noc3_data  ),
        .noc_ready_out  ( buf_mem_noc3_ready )
    );

`endif

`endif // endif PITONSYS_NO_MC


wire net_interrupt;
wire uart_interrupt;
wire uart2_interrupt;

wire                        ciop_iob_noc2_out_val;
wire [`NOC_DATA_WIDTH-1:0]  ciop_iob_noc2_out_data;
wire                        ciop_iob_noc2_out_rdy;

<% 
# Order of interrupts in irq_sources should be consistent with
# order of devices in devices_ariane.xml
num_interrupts = 3
devs_with_ints = []
int_triggers = []
for i in range(len(devices)):
    if devices[i]["name"] == "uart":
        devs_with_ints += ["uart_interrupt"]
        int_triggers += ["1'b0"]
    elif devices[i]["name"] == "uart2":
        devs_with_ints += ["uart2_interrupt"]
        int_triggers += ["1'b0"]
    elif devices[i]["name"] == "net": 
        devs_with_ints += ["net_interrupt"]
        int_triggers += ["1'b1"]

print("wire [%d:0] irq_sources, irq_le, irq_id;" % (3*num_interrupts-1))
    
sources_str = "%s};" % devs_with_ints[0]
for dev in devs_with_ints[1:]:
    sources_str = "%s, %s" % (dev, sources_str)
for i in range(num_interrupts - len(devs_with_ints)):
    sources_str = "1'b0, %s" % sources_str
sources_str = "assign irq_sources = {" + sources_str
print(sources_str)
    
le_str = "%s};" % int_triggers[0]
for trig in int_triggers[1:]:
    le_str = "%s, %s" % (trig, le_str)
for i in range(num_interrupts - len(int_triggers)):
    le_str = "1'b0, %s" % le_str
le_str = "assign irq_le = {" + le_str
print(le_str)

id_str = "5'd1};"
for id in range(1, num_interrupts):
    id_str = "%s, %s" % ("5'd"+str(id+1), id_str)
id_str = "assign irq_id = {" + id_str
print(id_str)
    
%>


`ifdef PITON_RVIC

int_noc_bridge int_noc_bridge(
    .chip_clk               ( chipset_clk ),
    .fpga_clk               ( chipset_clk ),
    .rst_n                  ( chipset_rst_n ),

    .interrupt              ( irq_sources ),
    .irq_le                 ( irq_le      ), // 0:level, 1:edge
    .device_id              ( irq_id      ), // interrupt source device id, never use source 0

    .ciop_iob_out_val        ( ciop_iob_noc2_out_val  ),
    .ciop_iob_out_data       ( ciop_iob_noc2_out_data ),
    .ciop_iob_out_rdy        ( ciop_iob_noc2_out_rdy  ),

    .merger_iob_gen_noc_val  ( iob_filter_noc2_valid  ),
    .merger_iob_gen_noc_data ( iob_filter_noc2_data   ),
    .merger_iob_gen_noc_rdy  ( filter_iob_noc2_ready  )

);
`else

assign iob_filter_noc2_valid = ciop_iob_noc2_out_val;
assign iob_filter_noc2_data = ciop_iob_noc2_out_data;
assign ciop_iob_noc2_out_rdy = filter_iob_noc2_ready;

`endif


`ifdef PITONSYS_IOCTRL

wire ciop_iob_rst_n;
assign ciop_iob_rst_n = io_ctrl_rst_n & test_start & ~piton_ready_n;

ciop_iob ciop_iob     (
    .chip_clk        ( chipset_clk           ),
    .fpga_clk        ( chipset_clk           ),
    .rst_n           ( ciop_iob_rst_n        ),

    .noc1_in_val     ( intf_chipset_val_noc1 ),
    .noc1_in_data    ( intf_chipset_data_noc1),
    .noc1_in_rdy     ( intf_chipset_rdy_noc1 ),

    .noc2_out_val    ( ciop_iob_noc2_out_val ),
    .noc2_out_data   ( ciop_iob_noc2_out_data ),
    .noc2_out_rdy    ( ciop_iob_noc2_out_rdy ),

    .noc3_in_val     ( filter_iob_noc3_valid ),
    .noc3_in_data    ( filter_iob_noc3_data  ),
    .noc3_in_rdy     ( iob_filter_noc3_ready ),

    .noc2_in_val     ( buf_iob_noc2_valid    ),
    .noc2_in_data    ( buf_iob_noc2_data     ),
    .noc2_in_rdy     ( iob_buf_noc2_ready    ),

    .noc3_out_val    ( iob_buf_noc3_valid    ),
    .noc3_out_data   ( iob_buf_noc3_data     ),
    .noc3_out_rdy    ( buf_iob_noc3_ready    ),

`ifdef PITON_RVIC
    .uart_interrupt ( uart_interrupt         ),
    .net_interrupt  ( net_interrupt          )
`else
    .uart_interrupt (1'b0), 
    .net_interrupt  (1'b0)
`endif
);


`ifdef PITONSYS_UART
<%
for i in range(1, len(devices)):
    if devices[i]["name"] == "uart":
        print('''
uart_top        uart_top (
    .axi_clk                    ( chipset_clk                           ),
    .rst_n                      ( chipset_rst_n                         ),

    .uart_rx                    ( uart_rx                               ),
    .uart_tx                    ( uart_tx                               ),
`ifdef PITONSYS_UART_CTS
    .uart_rtsn                  ( uart_rtsn                              ),
    .uart_ctsn                  ( uart_ctsn                              ),
`endif
    .uart_interrupt             ( uart_interrupt                        ),
`ifdef PITONSYS_UART_LOOBACK
    // Can be used to loobpack UART for testing
    .uart_lb_sw                 ( 1'b1                                  ),
`else // ifndef PITONSYS_UART_LOOBACK
    .uart_lb_sw                 ( 1'b0                                  ),
`endif // endif PITONSYS_UART_LOOBACK

    .uart_boot_en               ( uart_boot_en                          ),
`ifndef PITONSYS_NO_MC
`ifdef PITON_FPGA_MC_DDR
    .init_calib_complete        (init_calib_complete                    ),
`else // PITON_FPGA_MC_DDR
    .init_calib_complete        (1'b1                                   ),
`endif //PITON_FPGA_MC_DDR
`else // PITONSYS_NO_MC
    .init_calib_complete        (1'b1                                   ),
`endif // PITONSYS_NO_MC

    // Uncomment to connect to the switch
    // .uart_timeout_en(uart_timeout_en),
    .uart_timeout_en            ( 1'b1                                  ),

    .test_start                 ( test_start                            ),
    .test_good_end              ( test_good_end                         ),
    .test_bad_end               ( test_bad_end                          ),
    .uart_rst_out_n             ( uart_rst_out_n                        ),

`ifdef PITON_MULTICHIP
    .chip_id                    ( chipid                                ),
`else
    .chip_id                    ( {1'b1, {(`NOC_CHIPID_WIDTH-1){1'b0}}} ),
`endif
    .x_id                       ( `NOC_X_WIDTH'd%s                      ),
    .y_id                       ( `NOC_Y_WIDTH'd0                       ),
    // input from noc2
    .xbar_uart_noc2_valid       ( buf_uart_noc2_valid                   ),
    .xbar_uart_noc2_data        ( buf_uart_noc2_data                    ),
    .uart_xbar_noc2_ready       ( uart_buf_noc2_ready                   ),

    //output to noc3
    .uart_xbar_noc3_valid       ( uart_buf_noc3_valid                   ),
    .uart_xbar_noc3_data        ( uart_buf_noc3_data                    ),
    .xbar_uart_noc3_ready       ( buf_uart_noc3_ready                   ),

    // output to noc2
    .uart_xbar_noc2_valid       ( uart_filter_noc2_valid                ),
    .uart_xbar_noc2_data        ( uart_filter_noc2_data                 ),
    .xbar_uart_noc2_ready       ( filter_uart_noc2_ready                ),

    // input from noc3
    .xbar_uart_noc3_valid       ( filter_uart_noc3_valid                ),
    .xbar_uart_noc3_data        ( filter_uart_noc3_data                 ),
    .uart_xbar_noc3_ready       ( uart_filter_noc3_ready                )
);''' % (devices[i]["portnum"]))
%>
`else // ifndef PITONSYS_UART
    assign uart_interrupt = 1'b0;
    assign test_start = 1'b1;
`endif // endif PITONSYS_UART

`ifdef PITONSYS_UART2
<%
for i in range(1, len(devices)):
    if devices[i]["name"] == "uart2":
        print('''

uart_lite uart2(
    .axi_clk                    ( chipset_clk                           ),
    .rst_n                      ( chipset_rst_n                         ),

    .uart_rx                    ( uart2_rx                               ),
    .uart_tx                    ( uart2_tx                               ),
`ifdef PITONSYS_UART_CTS
    .uart_ctsn                  ( uart2_ctsn                             ),
    .uart_rtsn                  ( uart2_rtsn                             ),
`endif
    .uart_interrupt             ( uart2_interrupt                        ),

    .xbar_uart_noc2_valid       ( buf_uart2_noc2_valid                   ),
    .xbar_uart_noc2_data        ( buf_uart2_noc2_data                    ),
    .uart_xbar_noc2_ready       ( uart2_buf_noc2_ready                   ),

    //output to noc3
    .uart_xbar_noc3_valid       ( uart2_buf_noc3_valid                   ),
    .uart_xbar_noc3_data        ( uart2_buf_noc3_data                    ),
    .xbar_uart_noc3_ready       ( buf_uart2_noc3_ready                   )
);

''')
%>
`else // PITONSYS_UART2
assign uart2_interrupt = 1'b0;
`endif // endif PITONSYS_UART2

// SPI interface
`ifdef PITONSYS_SPI
`ifdef PITON_FPGA_SD_BOOT

    /* Bridge between NOCs and SD Card */
    piton_sd_top piton_sd_top (
        .sys_clk          ( chipset_clk       ),
        .sd_clk           ( sd_clk            ),
        .sys_rst          ( ~chipset_rst_n    ),

        .splitter_sd_val  ( buf_sd_noc2_valid ),
        .splitter_sd_data ( buf_sd_noc2_data  ),
        .sd_splitter_rdy  ( sd_buf_noc2_ready ),

        .sd_splitter_val  ( sd_buf_noc3_valid ),
        .sd_splitter_data ( sd_buf_noc3_data  ),
        .splitter_sd_rdy  ( buf_sd_noc3_ready ),

        .sd_cd            ( sd_cd             ),
        .sd_reset         ( sd_reset          ),
        .sd_clk_out       ( sd_clk_out        ),
        .sd_cmd           ( sd_cmd            ),
        .sd_dat           ( sd_dat            )
        );

`endif
`endif



`ifdef PITON_FPGA_ETHERNETLITE

    eth_top #(
    `ifdef PITON_ARIANE
      .SWAP_ENDIANESS(1)
    `else
      .SWAP_ENDIANESS(0)
    `endif
    ) eth_top (
        .chipset_clk     ( chipset_clk        ),
        .rst_n           ( chipset_rst_n      ),

        .net_interrupt   ( net_interrupt      ),

        .noc_in_val      ( buf_net_noc2_valid ),
        .noc_in_data     ( buf_net_noc2_data  ),
        .noc_in_rdy      ( net_buf_noc2_ready ),

        .noc_out_val     ( net_buf_noc3_valid ),
        .noc_out_data    ( net_buf_noc3_data  ),
        .noc_out_rdy     ( buf_net_noc3_ready ),

        .net_axi_clk     ( net_axi_clk        ),
        .net_phy_rst_n   ( net_phy_rst_n      ),

        .net_phy_tx_clk  ( net_phy_tx_clk     ),
        .net_phy_tx_en   ( net_phy_tx_en      ),
        .net_phy_tx_data ( net_phy_tx_data    ),

        .net_phy_rx_clk  ( net_phy_rx_clk     ),
        .net_phy_dv      ( net_phy_dv         ),
        .net_phy_rx_data ( net_phy_rx_data    ),
        .net_phy_rx_er   ( net_phy_rx_er      ),

        .net_phy_mdio_io ( net_phy_mdio_io    ),
        .net_phy_mdc     ( net_phy_mdc        )
    );
`endif // PITON_FPGA_ETHERNETLITE

`else // PITONSYS_IOCTRL

assign net_interrupt  = 1'b0;
assign uart_interrupt = 1'b0;
assign uart2_interrupt = 1'b0;

// Fake iobridge
// Tie noc1 input low because it's unused
assign intf_chipset_rdy_noc1 = 1'b0;
ciop_fake_iob ciop_fake_iob(
    .noc_out_val       ( ciop_iob_noc2_out_val ),
    .noc_out_rdy       ( ciop_iob_noc2_out_rdy ),
    .noc_out_data      ( ciop_iob_noc2_out_data  ),

    <%
        text = r'''
        .spc0_inst_done    (`PITON_CORE0_INST_DONE),
        .pc_w0             (`PITON_CORE0_PC_W0),
        '''

        for i in range (PITON_NUM_TILES):
            text2 = text;
            text2 = text2.replace("PITON_CORE0", "PITON_CORE" + repr(i));
            text2 = text2.replace("spc0_inst_done", "spc" + repr(i) + "_inst_done");
            text2 = text2.replace("pc_w0", "pc_w" + repr(i));
            text2 = text2.replace("PC_W0", "PC_W" + repr(i));
            print(text2)
    %>
    .clk               (chipset_clk),
    .rst_n             (chipset_rst_n)
//    .rst_n             (`SPARC_CORE0.reset_l)
);

// I/O AXI splitter, needed for uart-hello-world.s
fake_uart fake_uart (
    .clk                ( chipset_clk         ),
    .rst_n              ( chipset_rst_n       ),

    .src_uart_noc2_val  ( buf_uart_noc2_valid ),
    .src_uart_noc2_data ( buf_uart_noc2_data  ),
    .src_uart_noc2_rdy  ( uart_buf_noc2_ready ),

    .uart_dst_noc3_val  ( uart_buf_noc3_valid ),
    .uart_dst_noc3_data ( uart_buf_noc3_data  ),
    .uart_dst_noc3_rdy  ( buf_uart_noc3_ready )
);
`endif // endif PITONSYS_IOCTRL


/////////////////////////////
// Ariane-Specific Chipset //
/////////////////////////////

`ifdef PITON_ARIANE


    // this is for selecting the right bootrom (1: baremetal, 0: linux)
    wire ariane_boot_sel;
`ifdef PITON_FPGA_SYNTH
  assign ariane_boot_sel   = uart_boot_en;
`else
  `ifdef ARIANE_SIM_LINUX_BOOT
    assign ariane_boot_sel = 1'b0;
  `else
    assign ariane_boot_sel = 1'b1;
  `endif
`endif

<%
DmBase    = 0
RomBase   = 0
ClintBase = 0
PlicBase  = 0
for i in range(len(devices)):
    if devices[i]["name"] == "ariane_debug":
        DmBase = devices[i]["base"]
    if devices[i]["name"] == "ariane_bootrom":
        RomBase = devices[i]["base"]
    if devices[i]["name"] == "ariane_clint":
        ClintBase = devices[i]["base"]
    if devices[i]["name"] == "ariane_plic":
        PlicBase = devices[i]["base"]
str = '''
    riscv_peripherals #(
        .DataWidth      ( `NOC_DATA_WIDTH ),
        .NumHarts       ( `PITON_NUM_TILES),
        .NumSources     (              %d ),
        .PlicMaxPriority(               7 ),
        .SwapEndianess  (               1 ),
        .DmBase         ( 64'h%016x ),
        .RomBase        ( 64'h%016x ),
        .ClintBase      ( 64'h%016x ),
        .PlicBase       ( 64'h%016x )
    ) i_riscv_peripherals (
        .clk_i                           ( chipset_clk                   ),
        .rst_ni                          ( chipset_rst_n                 ),
        .testmode_i                      ( 1'b0                          ),
        .buf_ariane_debug_noc2_data_i    ( buf_ariane_debug_noc2_data    ),
        .buf_ariane_debug_noc2_valid_i   ( buf_ariane_debug_noc2_valid   ),
        .ariane_debug_buf_noc2_ready_o   ( ariane_debug_buf_noc2_ready   ),
        .ariane_debug_buf_noc3_data_o    ( ariane_debug_buf_noc3_data    ),
        .ariane_debug_buf_noc3_valid_o   ( ariane_debug_buf_noc3_valid   ),
        .buf_ariane_debug_noc3_ready_i   ( buf_ariane_debug_noc3_ready   ),
        .buf_ariane_bootrom_noc2_data_i  ( buf_ariane_bootrom_noc2_data  ),
        .buf_ariane_bootrom_noc2_valid_i ( buf_ariane_bootrom_noc2_valid ),
        .ariane_bootrom_buf_noc2_ready_o ( ariane_bootrom_buf_noc2_ready ),
        .ariane_bootrom_buf_noc3_data_o  ( ariane_bootrom_buf_noc3_data  ),
        .ariane_bootrom_buf_noc3_valid_o ( ariane_bootrom_buf_noc3_valid ),
        .buf_ariane_bootrom_noc3_ready_i ( buf_ariane_bootrom_noc3_ready ),
        .buf_ariane_clint_noc2_data_i    ( buf_ariane_clint_noc2_data    ),
        .buf_ariane_clint_noc2_valid_i   ( buf_ariane_clint_noc2_valid   ),
        .ariane_clint_buf_noc2_ready_o   ( ariane_clint_buf_noc2_ready   ),
        .ariane_clint_buf_noc3_data_o    ( ariane_clint_buf_noc3_data    ),
        .ariane_clint_buf_noc3_valid_o   ( ariane_clint_buf_noc3_valid   ),
        .buf_ariane_clint_noc3_ready_i   ( buf_ariane_clint_noc3_ready   ),
        .buf_ariane_plic_noc2_data_i     ( buf_ariane_plic_noc2_data     ),
        .buf_ariane_plic_noc2_valid_i    ( buf_ariane_plic_noc2_valid    ),
        .ariane_plic_buf_noc2_ready_o    ( ariane_plic_buf_noc2_ready    ),
        .ariane_plic_buf_noc3_data_o     ( ariane_plic_buf_noc3_data     ),
        .ariane_plic_buf_noc3_valid_o    ( ariane_plic_buf_noc3_valid    ),
        .buf_ariane_plic_noc3_ready_i    ( buf_ariane_plic_noc3_ready    ),
        // This selects either the BM or linux bootrom
        .ariane_boot_sel_i               ( ariane_boot_sel               ),
        // Debug sigs to cores
        .ndmreset_o                      ( ndmreset_o                    ),
        .dmactive_o                      ( dmactive_o                    ),
        .debug_req_o                     ( debug_req_o                   ),
        .unavailable_i                   ( unavailable_i                 ),
        // JTAG
        .tck_i                           ( tck_i                         ),
        .tms_i                           ( tms_i                         ),
        .trst_ni                         ( trst_ni                       ),
        .td_i                            ( td_i                          ),
        .td_o                            ( td_o                          ),
        .tdo_oe_o                        (                               )
    `ifndef PITON_RVIC
    ,
        // CLINT
        .rtc_i                           ( rtc_i                         ),
        .timer_irq_o                     ( timer_irq_o                   ),
        .ipi_o                           ( ipi_o                         ),
        // PLIC
        .irq_le_i                        ( irq_le                        ), // 0:level 1:edge
        .irq_sources_i                   ( irq_sources                   ),
        .irq_o                           ( irq_o                         )
    `endif
    );
''' % (len(devs_with_ints), int(DmBase), int(RomBase), int(ClintBase), int(PlicBase))
print(str)
%>

`else

    // tie off unused sigs
    assign ariane_debug_buf_noc2_ready   = 1'b0;
    assign ariane_debug_buf_noc3_data    = `NOC_DATA_WIDTH'b0;
    assign ariane_debug_buf_noc3_valid   = 1'b0;

    assign ariane_bootrom_buf_noc2_ready = 1'b0;
    assign ariane_bootrom_buf_noc3_data  = `NOC_DATA_WIDTH'b0;
    assign ariane_bootrom_buf_noc3_valid = 1'b0;

    assign ariane_clint_buf_noc2_ready   = 1'b0;
    assign ariane_clint_buf_noc3_data    = `NOC_DATA_WIDTH'b0;
    assign ariane_clint_buf_noc3_valid   = 1'b0;

    assign ariane_plic_buf_noc2_ready    = 1'b0;
    assign ariane_plic_buf_noc3_data     = `NOC_DATA_WIDTH'b0;
    assign ariane_plic_buf_noc3_valid    = 1'b0;

`endif


`ifdef PITON_GNG_ACC
    gng_top gng_top(
        .clk(chipset_clk), 
        .rst_n(chipset_rst_n), 

        .in_val(buf_gng_noc2_valid), 
        .in_data(buf_gng_noc2_data), 
        .in_rdy(gng_buf_noc2_ready), 

        .out_val(gng_buf_noc3_valid), 
        .out_data(gng_buf_noc3_data), 
        .out_rdy(buf_gng_noc3_ready)
    );
`endif

endmodule
